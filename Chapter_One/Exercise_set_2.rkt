#lang sicp
;Exercise 1.9  (a)

; the most important thing to know about recursion is that you're always substituting the function/parameter with either the predicate or the consequent

(define (+ a b)
 (if (= a 0) b (inc (+ (dec a) b)))
  )

(+ 4 5)

; using the substitution model, the process generated by the procedure above will look like this:
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc ( + 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

; this shows that the recursive procedure above uses a recursive process because there're some information hidden
; by the interpreter that are not captured in the variable, but are needed to get the desired result.
; In this case, the state of b doesn't really change. The interpreter has to keep track of the entire chain
; of the procedure, in order to reduce and evaluate the result once a = 0 and b is pased into the innermost
; function call of the chain.

;Exercise 1.9  (b)
(define (++ c d)
  (if (= c 0) d (+ (dec c) (inc d))))

(+ 4 5)

; Notice that in this case, the second variable that will be returned if the predicate is true, changes its state during each round of the recursive procedure.
; hence, all the interpreter needs to run the program, are the most recent states of the variables (c and d) after each round of recursive procedure. the final state of d is returned
; once the predicate is true.


; Exercise 1.10
( define (A x y)
   (cond ((= y 0) 0)
     ((= x 0) (* 2 y))
     ((= y 1) 2)
     (else (A(- x 1) (A x (- y 1))))
    )
 )


; Exercise 1.11

; a. computation with a recursive process
(define (funf n)
  (if (< n 3)
      n
      (+ (funf (- n 1)) (+ (* 2 (funf (- n 2))) (* 3 (funf(- n 3)))))))

; b. computation with a iterative process
(define (f n) 
   (define (iter a b c count) 
     (if (= count 0) 
       a 
       (iter b c (+ c (+ (* 2 b) (* 3 a))) (- count 1)))) 
   (iter 0 1 2 n))

(funf 5)

(f 5)
