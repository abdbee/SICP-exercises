#lang sicp
;Exercise 1.9  (a)

; the most important thing to know about recursion is that you're always substituting the function/parameter with either the predicate or the consequent

(define (+ a b)
 (if (= a 0) b (inc (+ (dec a) b)))
  )

(+ 4 5)

; using the substitution model, the process generated by the procedure above will look like this:
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc ( + 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

; this shows that the recursive procedure above uses a recursive process because there're some information hidden
; by the interpreter that are not captured in the variable, but are needed to get the desired result.
; In this case, the state of b doesn't really change. The interpreter has to keep track of the entire chain
; of the procedure, in order to reduce and evaluate the result once a = 0 and b is pased into the innermost
; function call of the chain.

;Exercise 1.9  (b)
(define (++ c d)
  (if (= c 0) d (+ (dec c) (inc d))))

(+ 4 5)

; Notice that in this case, the second variable that will be returned if the predicate is true, changes its state during each round of the recursive procedure.
; hence, all the interpreter needs to run the program, are the most recent states of the variables (c and d) after each round of recursive procedure. the final state of d is returned
; once the predicate is true.